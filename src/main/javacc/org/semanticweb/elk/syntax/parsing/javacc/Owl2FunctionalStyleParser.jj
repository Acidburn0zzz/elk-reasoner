/*
 * #%L
 * elk-reasoner
 * 
 * $Id$
 * $HeadURL$
 * %%
 * Copyright (C) 2011 Oxford University Computing Laboratory
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
/** OWL 2 JavaCC parser
 * 
 * Follows the official OWL 2 specifications: 
 * http://www.w3.org/TR/owl2-syntax/#Appendix:_Complete_Grammar_.28Normative.29
 * Some lexing definitions use terminals from SPQRQL specification:  
 * http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/#sparqlGrammar
 * 
 * @author Yevgeny Kazakov, Apr 19, 2011
 */

options
{
  UNICODE_INPUT = true;
  CACHE_TOKENS = true;
  STATIC = false;
}  

PARSER_BEGIN(Owl2FunctionalStyleParser)

package org.semanticweb.elk.parser.javacc;

import java.util.Vector;
import java.util.concurrent.Future;

import org.semanticweb.elk.syntax.parsing.FutureElkAxiomConsumer;
import org.semanticweb.elk.syntax.ElkAxiom;
import org.semanticweb.elk.syntax.ElkClass;
import org.semanticweb.elk.syntax.ElkClassAxiom;
import org.semanticweb.elk.syntax.ElkClassExpression;
import org.semanticweb.elk.syntax.ElkDeclarationAxiom;
import org.semanticweb.elk.syntax.ElkEntity;
import org.semanticweb.elk.syntax.ElkEquivalentClassesAxiom;
import org.semanticweb.elk.syntax.ElkObjectIntersectionOf;
import org.semanticweb.elk.syntax.ElkObjectInverseOf;
import org.semanticweb.elk.syntax.ElkObjectProperty;
import org.semanticweb.elk.syntax.ElkObjectPropertyAxiom;
import org.semanticweb.elk.syntax.ElkObjectPropertyChain;
import org.semanticweb.elk.syntax.ElkObjectPropertyExpression;
import org.semanticweb.elk.syntax.ElkObjectSomeValuesFrom;
import org.semanticweb.elk.syntax.ElkSubClassOfAxiom;
import org.semanticweb.elk.syntax.ElkSubObjectPropertyOfAxiom;
import org.semanticweb.elk.syntax.ElkTransitiveObjectPropertyAxiom;
import org.semanticweb.elk.syntax.FutureElkObjectFactory;
import org.semanticweb.elk.syntax.FutureElkObjectFactoryImpl;

public class Owl2FunctionalStyleParser {
    boolean initialized = false;

    private static FutureElkObjectFactory constructor =
        new FutureElkObjectFactoryImpl();

    public void Init(java.io.InputStream stream, String encoding) {
        if (initialized) {
            ReInit(stream, encoding);
        } else {
            new Owl2FunctionalStyleParser(stream, encoding);
        }
        initialized = true;
    }

    public void Init(java.io.InputStream stream) {
        Init(stream, null);
    }
    
}

PARSER_END(Owl2FunctionalStyleParser)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
  < OPEN_BRACE: "(" >
| < CLOSE_BRACE: ")" >
| < EQUALS: "=" >
| < REFERENCE: "^^" >

/* Reserved Keywords */
| < OWL_BACKWARD_COMPATIBLE_WITH: "owl:backwardCompatibleWith" >
| < OWL_BOTTOM_DATA_PROPERTY: "owl:bottomDataProperty" >
| < OWL_BOTTOM_OBJECT_PROPERTY: "owl:bottomObjectProperty" >
| < OWL_DEPRECATED: "owl:deprecated" >
| < OWL_INCOMPATIBLE_WITH: "owl:incompatibleWith" >
| < OWL_NOTHING: "owl:Nothing" >
| < OWL_PRIOR_VERSION: "owl:priorVersion" >
| < OWL_RATIONAL: "owl:rational" >
| < OWL_REAL: "owl:real" >
| < OWL_VERSION_INFO: "owl:versionInfo" >
| < OWL_THING: "owl:Thing" >
| < OWL_TOP_DATA_PROPERTY: "owl:topDataProperty" >
| < OWL_TOP_OBJECT_PROPERTY: "owl:topObjectProperty" >
| < RDF_LANG_RANGE: "rdf:langRange" >
| < RDF_PLAIN_LITERAL: "rdf:PlainLiteral" >
| < RDF_XML_LITERAL: "rdf:XMLLiteral" >
| < RDFS_COMMENT: "rdfs:comment" >
| < RDFS_IS_DEFINED_BY: "rdfs:isDefinedBy" >
| < RDFS_LABEL: "rdfs:label" >
| < RDFS_LITERAL: "rdfs:Literal" >
| < RDFS_SEE_ALSO: "rdfs:seeAlso" >
| < XSD_ANY_URI: "xsd:anyURI" >
| < XSD_BASE_64_BINARY: "xsd:base64Binary" >
| < XSD_BOOLEAN: "xsd:boolean" >
| < XSD_BYTE: "xsd:byte" >
| < XSD_DATE_TIME: "xsd:dateTime" >
| < XSD_DATE_TIME_STAMP: "xsd:dateTimeStamp" >
| < XSD_DECIMAL: "xsd:decimal" >
| < XSD_DOUBLE: "xsd:double" >
| < XSD_FLOAT: "xsd:float" >
| < XSD_HEX_BINARY: "xsd:hexBinary" >
| < XSD_INT: "xsd:int" >
| < XSD_INTEGER: "xsd:integer" >
| < XSD_LANGUAGE: "xsd:language" >
| < XSD_LENGTH: "xsd:length" >
| < XSD_LONG: "xsd:long" >
| < XSD_MAX_EXCLUSIVE: "xsd:maxExclusive" >
| < XSD_MAX_INCLUSIVE: "xsd:maxInclusive" >
| < XSD_MAX_LENGTH: "xsd:maxLength" >
| < XSD_MIN_EXCLUSIVE: "xsd:minExclusive" >
| < XSD_MIN_INCLUSIVE: "xsd:minInclusive" >
| < XSD_MIN_LENGTH: "xsd:minLength" >
| < XSD_NAME: "xsd:Name" >
| < XSD_NC_NAME: "xsd:NCName" >
| < XSD_NEGATIVE_INTEGER: "xsd:negativeInteger" >
| < XSD_NMTOKEN: "xsd:NMTOKEN" >
| < XSD_NON_NEGATIVE_INTEGER: "xsd:nonNegativeInteger" >
| < XSD_NON_POSITIVE_INTEGER: "xsd:nonPositiveInteger" >
| < XSD_NORMALIZED_STRING: "xsd:normalizedString" >
| < XSD_PATTERN: "xsd:pattern" >
| < XSD_POSITIVE_INTEGER: "xsd:positiveInteger" >
| < XSD_SHORT: "xsd:short" >
| < XSD_STRING: "xsd:string" >
| < XSD_TOKEN: "xsd:token" >
| < XSD_UNSIGNED_BYTE: "xsd:unsignedByte" >
| < XSD_UNSIGNED_INT: "xsd:unsignedInt" >
| < XSD_UNSIGNED_LONG: "xsd:unsignedLong" >
| < XSD_UNSIGNED_SHORT: "xsd:unsignedShort" >
   
/* Ontology Keywords */
| < PREFIX: "Prefix" >
| < ONTOLOGY: "Ontology" >
| < IMPORT: "Import" >
  
/* Entities and Literals */
| < CLASS: "Class" >
| < DATATYPE: "Datatype" >
| < OBJECT_PROPERTY: "ObjectProperty" >
| < DATA_PROPERTY: "DataProperty" >
| < ANNOTATION_PROPERTY: "AnnotationProperty" >
| < NAMED_INDIVIDUAL: "NamedIndividual" >
  
/* Declaration */
| < DECLARATION: "Declaration" >
  
/* Property Expressions */
| < OBJECT_INVERSE_OF: "ObjectInverseOf" >
| < OBJECT_PROPERTY_CHAIN: "ObjectPropertyChain" >
    
/* Data Ranges */
| < COMPLEMENT_OF: "ComplementOf" >
| < ONE_OF: "OneOf" >
| < DATATYPE_RESTRICTION: "DatatypeRestriction" >
    
/* Class Expressions */  
| < OBJECT_INTERSECTION_OF: "ObjectIntersectionOf" >
| < OBJECT_UNION_OF: "ObjectUnionOf" >
| < OBJECT_COMPLEMENT_OF: "ObjectComplementOf" >
| < OBJECT_ONE_OF: "ObjectOneOf" >
| < OBJECT_SOME_VALUES_FROM: "ObjectSomeValuesFrom" >
| < OBJECT_ALL_VALUES_FROM: "ObjectAllValuesFrom" >
| < OBJECT_HAS_VALUE: "ObjectHasValue" >
| < OBJECT_HAS_SELF: "ObjectHasSelf" >
| < OBJECT_MIN_CARDINALITY: "ObjectMinCardinality" >
| < OBJECT_MAX_CARDINALITY: "ObjectMaxCardinality" >
| < OBJECT_EXACT_CARDINALITY: "ObjectExactCardinality" >
| < DATA_INTERSECTION_OF: "DataIntersectionOf" >
| < DATA_UNION_OF: "DataUnionOf" >
| < DATA_COMPLEMENT_OF: "DataComplementOf" >
| < DATA_ONE_OF: "DataOneOf" >
| < DATA_SOME_VALUES_FROM: "DataSomeValuesFrom" >
| < DATA_ALL_VALUES_FROM: "DataAllValuesFrom" >
| < DATA_HAS_VALUE: "DataHasValue" >
| < DATA_MIN_CARDINALITY: "DataMinCardinality" >
| < DATA_MAX_CARDINALITY: "DataMaxCardinality" >
| < DATA_EXACT_CARDINALITY: "DataExactCardinality" >
   
/* Class Expressions Axioms */
| < SUB_CLASS_OF: "SubClassOf" >
| < EQUIVALENT_CLASSES: "EquivalentClasses" >
| < DISJOINT_CLASSES: "DisjointClasses" >
| < DISJOINT_UNION: "DisjointUnion" >
    
/* Object Property Axioms */ 
| < SUB_OBJECT_PROPERTY_OF: "SubObjectPropertyOf" >
| < EQUIVALENT_OBJECT_PROPERTIES: "EquivalentObjectProperties" >
| < DISJOINT_OBJECT_PROPERTIES: "DisjointObjectProperties" >
| < OBJECT_PROPERTY_DOMAIN: "ObjectPropertyDomain" >
| < OBJECT_PROPERTY_RANGE: "ObjectPropertyRange" >
| < INVERSE_OBJECT_PROPERTIES: "InverseObjectProperties" >
| < FUNCTIONAL_OBJECT_PROPERTY: "FunctionalObjectProperty" >
| < INVERSE_FUNCTIONAL_OBJECT_PROPERTY: "InverseFunctionalObjectProperty" >
| < REFLEXIVE_OBJECT_PROPERTY: "ReflexiveObjectProperty" >
| < IRREFLEXIVE_OBJECT_PROPERTY: "IrreflexiveObjectProperty" >
| < SYMMETRIC_OBJECT_PROPERTY: "SymmetricObjectProperty" >
| < ASYMMETRIC_OBJECT_PROPERTY: "AsymmetricObjectProperty" >
| < TRANSITIVE_OBJECT_PROPERTY: "TransitiveObjectProperty" >
   
/* Data Property Axioms */          
| < SUB_DATA_PROPERTY_OF: "SubDataPropertyOf" >
| < EQUIVALENT_DATA_PROPERTIES: "EquivalentDataProperties" >
| < DISJOINT_DATA_PROPERTIES: "DisjointDataProperties" >
| < DATA_PROPERTY_DOMAIN: "DataPropertyDomain" >
| < DATA_PROPERTY_RANGE: "DataPropertyRange" >
| < FUNCTIONAL_DATA_PROPERTY: "FunctionalDataProperty" >
| < DATATYPE_DEFINITION: "DatatypeDefinition" >
  
/* Keys */        
| < HAS_KEY: "HasKey" >
    
/* Assertions */
| < SAME_INDIVIDUAL: "SameIndividual" >
| < DIFFERENT_INDIVIDUALS: "DifferentIndividuals" >
| < CLASS_ASSERTION: "ClassAssertion" >
| < OBJECT_PROPERTY_ASSERTION: "ObjectPropertyAssertion" >
| < NEGATIVE_OBJECT_PROPERTY_ASSERTION: "NegativeObjectPropertyAssertion" >
| < DATA_PROPERTY_ASSERTION: "DataPropertyAssertion" >
| < NEGATIVE_DATA_PROPERTY_ASSERTION: "NegativeDataPropertyAssertion" >
   
/* Annotations */
| < ANNOTATION: "Annotation" >
| < ANNOTATION_ASSERTION: "AnnotationAssertion" >
| < SUB_ANNOTATION_PROPERTY_OF: "SubAnnotationPropertyOf" >
| < ANNOTATION_PROPERTY_DOMAIN: "AnnotationPropertyDomain" >
| < ANNOTATION_PROPERTY_RANGE: "AnnotationPropertyRange" >

| < NON_NEGATIVE_INTEGER: ["1"-"9"] (<DIGIT>)* >
| < #DIGIT: ["0"-"9"] >
| < QUOTED_STRING:
       "\"" (
               ~["\\","\""] 
            |  ("\\" ("\""|"\'"|"\\")) 
            )* 
       "\""
  >
| < IRI_REF:
       "<" ( ~["<",">","\"","{","}","|","^","`","\\","\u0000"-"\u0020"] )* ">"
  > /* see IRI_REF of [SPARQL] */
| < PNAME_NS: (<PN_PREFIX>)? ":" >
| < PNAME_LN: <PNAME_NS> <PN_LOCAL> >
| < BLANK_NODE_LABEL: "_:" <PN_LOCAL> >
| < LANGTAG: "@" ( ["a"-"z","A"-"Z"])+ ("-" (["a"-"z","A"-"Z"]|<DIGIT>)+ )* >
| < #PN_CHARS_U: <PN_CHARS_BASE> | "_" >
| < #PN_CHARS: 
      <PN_CHARS_U> 
    | "-" 
    | <DIGIT> 
    | "\u00B7" 
    | ["\u0300"-"\u036F"] 
    | ["\u203F"-"\u2040"]
  >     
| < #PN_PREFIX: <PN_CHARS_BASE> ( ( <PN_CHARS> | "." )* <PN_CHARS> )? >
| < #PN_LOCAL: ( <PN_CHARS_U> | <DIGIT> ) ( ( <PN_CHARS> | "." )* <PN_CHARS>)? >
| < #PN_CHARS_BASE:
      ["a"-"z"] 
    | ["A"-"Z"] 
    | ["\u00C0"-"\u00D6"] 
    | ["\u00D8"-"\u00F6"] 
    | ["\u00F8"-"\u02FF"] 
    | ["\u0370"-"\u037D"] 
    | ["\u037F"-"\u1FFF"] 
    | ["\u200C"-"\u200D"] 
    | ["\u2070"-"\u218F"] 
    | ["\u2C00"-"\u2FEF"] 
    | ["\u3001"-"\uD7FF"] 
    | ["\uF900"-"\uFDCF"] 
    | ["\uFDF0"-"\uFFFD"]
  >
}

/*------------------------------------------------------------------
 * PARSER RULES
 *------------------------------------------------------------------*/

/* 2 Preliminary Definitions */
/* 2.3 Integers, Characters, Strings, Language Tags, and Node IDs */
/* @ (U+40) followed a nonempty sequence of characters matching the 
* langtag production from [BCP 47] 
*/
void languageTag():
{}
{
    <LANGTAG>
} /* See LANGTAG in [SPARQL] */ 
/* a finite sequence of characters matching the BLANK_NODE_LABEL 
* production of [SPARQL]
*/
void nodeId():
{}{
    <BLANK_NODE_LABEL>
}    
/* 2.3 IRIs */
/* an iri as defined in [RFC3987], enclosed in a pair of < (U+3C) and > 
* (U+3E) characters
*/
String fullIri():
{
  Token t;
}{
    t = <IRI_REF> {
      return t.image;
    }
} 
    /* See IRI_REF in [SPARQL] */
String iri():
{
  String x;
}{ (
    x = fullIri()           
|   x = abbreviatedIri()  
   ) { return x; }
}
/* a finite sequence of characters matching the PNAME_LN production of 
* [SPARQL] 
*/
String abbreviatedIri():
{
  Token t;
}{
    t = <PNAME_LN>   { return t.image; }
}
/* a finite sequence of characters matching the as PNAME_NS production of 
* [SPARQL] 
*/
void prefixName():
{}{
    <PNAME_NS>
}
/* 3 Ontologies */
/* 3.5 Ontology Annotations */
void ontologyAnnotations():
{}{
    ( annotation() )*
}
/* 3.7 Functional-Style Syntax */    
void ontologyDocument(FutureElkAxiomConsumer consumer):
{}{
    ( prefixDeclaration() )* ontology(consumer)
}
void prefixDeclaration():
{}{
    <PREFIX> <OPEN_BRACE>
      prefixName()
      <EQUALS>
      fullIri()
    <CLOSE_BRACE>
}
void ontology(FutureElkAxiomConsumer consumer):
{}{
    <ONTOLOGY> <OPEN_BRACE> ( ontologyIri() ( versionIri() )? )?
       directlyImportsDocuments()
       ontologyAnnotations()
       axioms(consumer)       
    <CLOSE_BRACE>
}
void ontologyIri():
{}{
    iri()
}
void versionIri():
{}{
    iri()
}
void directlyImportsDocuments():
{}{
    ( <IMPORT> <OPEN_BRACE> iri() <CLOSE_BRACE> )*
}
void axioms(FutureElkAxiomConsumer consumer):
{
    Future<? extends ElkAxiom> x;
}{
    ( x = axiom() { consumer.submit(x); } )*
}
/* 4 Datatype Maps */
/* 4.1 Real Numbers, Decimal Numbers, and Integers */ 
void dtRealsDecimalsIntegers():
{}{
    <OWL_REAL>
|   <OWL_RATIONAL>
|   <XSD_DECIMAL>
|   <XSD_INTEGER>
|   <XSD_NON_NEGATIVE_INTEGER>
|   <XSD_NON_POSITIVE_INTEGER>
|   <XSD_POSITIVE_INTEGER>
|   <XSD_NEGATIVE_INTEGER>
|   <XSD_LONG>
|   <XSD_INT>
|   <XSD_SHORT>
|   <XSD_BYTE>
|   <XSD_UNSIGNED_LONG>
|   <XSD_UNSIGNED_INT>
|   <XSD_UNSIGNED_SHORT>
|   <XSD_UNSIGNED_BYTE>
}
/* 4.2 Floating-Point Numbers */
void dtFloats():
{}{
    <XSD_DOUBLE>
|   <XSD_FLOAT>
}
/* 4.3 Strings */
void dtStrings():
{}{
    <RDF_PLAIN_LITERAL>
|   <XSD_STRING>
|   <XSD_NORMALIZED_STRING>
|   <XSD_TOKEN>
|   <XSD_LANGUAGE>
|   <XSD_NAME>
|   <XSD_NC_NAME>
|   <XSD_NMTOKEN>
}
/* 4.4 Boolean Values */
void dtBooleans():
{}{
    <XSD_BOOLEAN>
}
/* 4.5 Binary Data */
void dtBinaryData():
{}{
    <XSD_HEX_BINARY>
|   <XSD_BASE_64_BINARY>
}
/* 4.6 IRIs */
void dtIris():
{}{
    <XSD_ANY_URI>
}
/* 4.7 Time Instants */
void dtTimeInstants():
{}{
    <XSD_DATE_TIME_STAMP>
}
/* 4.8 XML Literals */
void dtXmlLiterals():
{}{
    <RDF_XML_LITERAL>
}
/* 5 Entities and Literals */
/* 5.1 Classes */
Future<? extends ElkClass> clazz():
{
  String x;
}{
    x = iri()     { return constructor.getFutureElkClass(x); }  
|   <OWL_THING>   { return constructor.getFuture(ElkClass.ELK_OWL_THING); }
|   <OWL_NOTHING> { return constructor.getFuture(ElkClass.ELK_OWL_NOTHING); }
}
/* 5.2 Datatypes */    
void datatype():
{}{
    iri()
|   <RDFS_LITERAL>
|   dtRealsDecimalsIntegers()
|   dtFloats()
|   dtStrings()
|   dtBooleans()
|   dtBinaryData()
|   dtIris()
|   dtTimeInstants()
|   dtXmlLiterals()
}
/* 5.3 Object Properties */       
Future<? extends ElkObjectProperty> objectProperty():
{
  String x;
}{
    x = iri() {
      return constructor.getFutureElkObjectProperty(x);
    }     
|   <OWL_TOP_OBJECT_PROPERTY> {
      return constructor.getFuture(
        ElkObjectProperty.ELK_OWL_TOP_OBJECT_PROPERTY);
    }
|   <OWL_BOTTOM_OBJECT_PROPERTY> {
      return constructor.getFuture(
        ElkObjectProperty.ELK_OWL_BOTTOM_OBJECT_PROPERTY);
    }
  
}
/* 5.4 Data Properties */    
void dataProperty():
{}{
    iri()
|   <OWL_TOP_DATA_PROPERTY>
|   <OWL_BOTTOM_DATA_PROPERTY>
}
/* 5.5 Annotation Properties */    
void annotationProperty():
{}{
    iri()
|   <RDFS_LABEL>
|   <RDFS_COMMENT>
|   <RDFS_SEE_ALSO>
|   <RDFS_IS_DEFINED_BY>
|   <OWL_DEPRECATED>
|   <OWL_VERSION_INFO>
|   <OWL_PRIOR_VERSION>
|   <OWL_BACKWARD_COMPATIBLE_WITH>
|   <OWL_INCOMPATIBLE_WITH>
}
/* 5.6 Individuals */
void individual():
{}{
    namedIndividual() 
|   anonymousIndividual()
}
/* 5.6.1 Named Individuals */
void namedIndividual():
{}{
    iri()
}
/* 5.6.2 Anonymous Individuals */    
void anonymousIndividual():
{}{
    nodeId()
}
/* 5.7 Literals */    
void literal():
{}{
    <QUOTED_STRING>
    (
      <REFERENCE> datatype()
    | ( languageTag() )?
    )    
}    

/* 5.8 Entity Declarations and Typing */
Future<? extends ElkDeclarationAxiom> declaration():
{
  Future<? extends ElkEntity> x;  
}{
    <DECLARATION> <OPEN_BRACE> axiomAnnotations()
    x = entity()
    <CLOSE_BRACE> {      
      return constructor.getFutureElkDeclarationAxiom(x);
    } 
}
Future<? extends ElkEntity> entity():
{
  Future<? extends ElkEntity> x = null;
}{ (
    <CLASS> <OPEN_BRACE> x = clazz() <CLOSE_BRACE> 
|   <DATATYPE> <OPEN_BRACE> datatype() <CLOSE_BRACE>
|   <OBJECT_PROPERTY> <OPEN_BRACE> x = objectProperty() <CLOSE_BRACE>
|   <DATA_PROPERTY> <OPEN_BRACE> dataProperty() <CLOSE_BRACE>
|   <ANNOTATION_PROPERTY> <OPEN_BRACE> annotationProperty() <CLOSE_BRACE>
|   <NAMED_INDIVIDUAL> <OPEN_BRACE> namedIndividual() <CLOSE_BRACE>
   ) { return x; }
}
/* 6 Property Expressions */    
Future<? extends ElkObjectPropertyExpression> objectPropertyExpression():
{
  Future<? extends ElkObjectPropertyExpression> x;
}{ (
    x = objectProperty()
|   x = inverseObjectProperty()
   ) { return x; }
}
/* 6.1.1 Inverse Object Properties */    
Future<? extends ElkObjectInverseOf> inverseObjectProperty():
{}{
    <OBJECT_INVERSE_OF> <OPEN_BRACE>
      objectProperty()
    <CLOSE_BRACE> {
      return null;
    } 
}
/* 6.2 Data Property Expressions */    
void dataPropertyExpression():
{}{
    dataProperty()
}
/* 7 Data Ranges */    
void dataRange():
{}{
    datatype() 
|   dataIntersectionOf() 
|   dataUnionOf() 
|   dataComplementOf()
|   dataOneOf() 
|   datatypeRestriction()
}
/* 7.1 Intersection of Data Ranges */    
void dataIntersectionOf():
{}{
    <DATA_INTERSECTION_OF> <OPEN_BRACE>
      dataRange()
      ( dataRange() )+
    <CLOSE_BRACE>
}
/* 7.2 Union of Data Ranges */
void dataUnionOf():
{}{
    <DATA_UNION_OF> <OPEN_BRACE>
      dataRange()
      ( dataRange() )+
    <CLOSE_BRACE>
}
/* 7.3 Complement of Data Ranges */    
void dataComplementOf():
{}{
    <DATA_COMPLEMENT_OF> <OPEN_BRACE>
      dataRange()
    <CLOSE_BRACE>
}
/* 7.4 Enumeration of Literals */
void dataOneOf():
{}{
    <DATA_ONE_OF> <OPEN_BRACE>
      ( literal() )+
    <CLOSE_BRACE>
}
/* 7.5 Datatype Restrictions */
void datatypeRestriction():
{}{
    <DATATYPE_RESTRICTION> <OPEN_BRACE> 
        datatype() 
        ( constrainingFacet() restrictionValue() )+ 
    <CLOSE_BRACE>
}
void constrainingFacet():
{}{
    iri()
|   <XSD_MIN_INCLUSIVE>
|   <XSD_MAX_INCLUSIVE>
|   <XSD_MIN_EXCLUSIVE>
|   <XSD_MAX_EXCLUSIVE>
|   <XSD_LENGTH>
|   <XSD_MIN_LENGTH>
|   <XSD_MAX_LENGTH>
|   <XSD_PATTERN>
|   <RDF_LANG_RANGE>
}
void restrictionValue():
{}{
    literal()
}
/* 8 Class Expressions */
Future<? extends ElkClassExpression> classExpression():
{
  Future<? extends ElkClassExpression> x = null;
}{ (
    x = clazz()      
|   x = objectIntersectionOf()
|   objectUnionOf()  
|   objectComplementOf()  
|   objectOneOf()   
|   x = objectSomeValuesFrom()
|   objectAllValuesFrom()
|   objectHasValue()
|   objectHasSelf()
|   objectMinCardinality()
|   objectMaxCardinality()
|   objectExactCardinality() 
|   dataSomeValuesFrom()
|   dataAllValuesFrom() 
|   dataHasValue()
|   dataMinCardinality()
|   dataMaxCardinality()
|   dataExactCardinality()
   ) { return x; }
}
/* 8.1 Propositional Connectives and Enumeration of Individuals */
/* 8.1.1 Intersection of Class Expressions */
Future<? extends ElkObjectIntersectionOf> objectIntersectionOf():
{
  Future<? extends ElkClassExpression> x;
  Vector<Future<? extends ElkClassExpression>> v =
      new Vector<Future<? extends ElkClassExpression>> ();  
}{
    <OBJECT_INTERSECTION_OF> <OPEN_BRACE> 
        x = classExpression() { v.add(x); }  
      ( x = classExpression() { v.add(x); } )+   
    <CLOSE_BRACE> {
        return constructor.getFutureElkObjectIntersectionOf(v);
    }
}
/* 8.1.2 Union of Class Expressions */
void objectUnionOf():
{}{
    <OBJECT_UNION_OF> <OPEN_BRACE>
      classExpression()
      ( classExpression() )+
    <CLOSE_BRACE>
}
/* 8.1.3 Complement of Class Expressions */
void objectComplementOf():
{}{
    <OBJECT_COMPLEMENT_OF> <OPEN_BRACE>
      classExpression()
    <CLOSE_BRACE>
}
/* 8.1.4 Enumeration of Individuals */    
void objectOneOf():
{}{
    <OBJECT_ONE_OF> <OPEN_BRACE>
      ( individual() )+
    <CLOSE_BRACE>
}
/* 8.2 Object Property Restrictions */
/* 8.2.1 Existential Quantification */    
Future<? extends ElkObjectSomeValuesFrom> objectSomeValuesFrom():
{
  Future<? extends ElkObjectPropertyExpression> x;
  Future<? extends ElkClassExpression> y;
}{
    <OBJECT_SOME_VALUES_FROM> <OPEN_BRACE>
      x = objectPropertyExpression()
      y = classExpression()
    <CLOSE_BRACE> {
      return constructor.getFutureElkObjectSomeValuesFrom(x, y);
    }
}
/* 8.2.2 Universal Quantification */
void objectAllValuesFrom():
{}{
    <OBJECT_ALL_VALUES_FROM> <OPEN_BRACE>
      objectPropertyExpression()
      classExpression()
    <CLOSE_BRACE>
}
/* 8.2.3 Individual Value Restriction */
void objectHasValue():
{}{
    <OBJECT_HAS_VALUE> <OPEN_BRACE>
      objectPropertyExpression()
      individual()
    <CLOSE_BRACE>
}
/* 8.2.4 Self-Restriction */
void objectHasSelf():
{}{
    <OBJECT_HAS_SELF> <OPEN_BRACE>
      objectPropertyExpression()
    <CLOSE_BRACE>
}
/* 8.3 Object Property Cardinality Restrictions */
/* 8.3.1 Minimum Cardinality */
void objectMinCardinality():
{}{
    <OBJECT_MIN_CARDINALITY> <OPEN_BRACE> 
        <NON_NEGATIVE_INTEGER> 
        objectPropertyExpression() 
        ( classExpression() )? 
    <CLOSE_BRACE>
}
/* 8.3.2 Maximum Cardinality */
void objectMaxCardinality():
{}{
    <OBJECT_MAX_CARDINALITY> <OPEN_BRACE> 
        <NON_NEGATIVE_INTEGER> 
        objectPropertyExpression() 
        ( classExpression() )? 
    <CLOSE_BRACE>
}
/* 8.3.3 Exact Cardinality */    
void objectExactCardinality():
{}{
    <OBJECT_EXACT_CARDINALITY> <OPEN_BRACE> 
        <NON_NEGATIVE_INTEGER> 
        objectPropertyExpression() 
        ( classExpression() )? 
    <CLOSE_BRACE>
}
/* 8.4 Data Property Restrictions */
/* 8.4.1 Existential Quantification */
void dataSomeValuesFrom():
{}{    
    <DATA_SOME_VALUES_FROM> <OPEN_BRACE>
      (LOOKAHEAD( 2 ) dataPropertyExpression() )+
      dataRange()
    <CLOSE_BRACE>
}
/* 8.4.2 Universal Quantification */
void dataAllValuesFrom():
{}{    
    <DATA_ALL_VALUES_FROM> <OPEN_BRACE>
      (LOOKAHEAD( 2 ) dataPropertyExpression() )+
      dataRange()
    <CLOSE_BRACE>
}
/* 8.4.3 Literal Value Restriction */
void dataHasValue():
{}{
    <DATA_HAS_VALUE> <OPEN_BRACE>
      dataPropertyExpression()
      literal()
    <CLOSE_BRACE>
}
/* 8.5 Data Property Cardinality Restrictions */
/* 8.5.1 Minimum Cardinality */
void dataMinCardinality():
{}{
    <DATA_MIN_CARDINALITY> <OPEN_BRACE> 
        <NON_NEGATIVE_INTEGER> 
        dataPropertyExpression() 
        ( dataRange() )? 
    <CLOSE_BRACE>
}
/* 8.5.2 Maximum Cardinality */
void dataMaxCardinality():
{}{
    <DATA_MAX_CARDINALITY> <OPEN_BRACE> 
        <NON_NEGATIVE_INTEGER> 
        dataPropertyExpression() 
        ( dataRange() )? 
    <CLOSE_BRACE>
}
/* 8.5.3 Exact Cardinality */
void dataExactCardinality():
{}{
    <DATA_EXACT_CARDINALITY> <OPEN_BRACE> 
        <NON_NEGATIVE_INTEGER> 
        dataPropertyExpression() 
        ( dataRange() )? 
    <CLOSE_BRACE>
}
/* 9 Axioms */
Future<? extends ElkAxiom> axiom():
{
  Future<? extends ElkAxiom> x = null;
}{ (
    declaration()
|   x = classAxiom()   
|   x = objectPropertyAxiom()
|   dataPropertyAxiom()
|   datatypeDefinition()
|   hasKey()
|   assertion()
|   annotationAxiom()
   ) { return x; }
}
void axiomAnnotations():
{}{
    ( annotation() )*
}    
/* 9.1 Class Expression Axioms */    
Future<? extends ElkClassAxiom> classAxiom():
{
  Future<? extends ElkClassAxiom> x = null;
}{ (
    x = subClassOf() 
|   x = equivalentClasses() 
|   disjointClasses()   
|   disjointUnion()
   ) { return x; }
}
/* 9.1.1 Subclass Axioms */
Future<? extends ElkSubClassOfAxiom> subClassOf():
{
  Future<? extends ElkClassExpression> x, y;
}{
    <SUB_CLASS_OF> <OPEN_BRACE> 
        axiomAnnotations() 
        x = classExpression() 
        y = classExpression() 
    <CLOSE_BRACE> {
      return constructor.getFutureElkSubClassOfAxiom(x, y);
    }    
}
/* 9.1.2 Equivalent Classes */
Future<? extends ElkEquivalentClassesAxiom> equivalentClasses():
{
  Future<? extends ElkClassExpression> x;
  Vector<Future<? extends ElkClassExpression>> v =
      new Vector<Future<? extends ElkClassExpression>> ();
}{
    <EQUIVALENT_CLASSES> <OPEN_BRACE> 
        axiomAnnotations() 
          x = classExpression() { v.add(x); }
        ( x = classExpression() { v.add(x); } )+ 
    <CLOSE_BRACE> {
      return constructor.getFutureElkEquivalentClassesAxiom(v);
    }    
}
/* 9.1.3 Disjoint Classes */
void disjointClasses():
{}{
    <DISJOINT_CLASSES> <OPEN_BRACE> 
        axiomAnnotations() 
        classExpression() 
        ( classExpression() )+ 
    <CLOSE_BRACE>
}
/* 9.1.4 Disjoint Union of Class Expressions */
void disjointUnion():
{}{
    <DISJOINT_UNION> <OPEN_BRACE>
      axiomAnnotations()
      clazz()
      disjointClassExpressions()
    <CLOSE_BRACE>
}
void disjointClassExpressions():
{}{
    classExpression() ( classExpression() )+
}
/* 9.2 Object Property Axioms */    
Future<? extends ElkObjectPropertyAxiom> objectPropertyAxiom():
{
    Future<? extends ElkObjectPropertyAxiom> x = null;
}{ (
    x = subObjectPropertyOf() 
|   equivalentObjectProperties()
|   disjointObjectProperties()
|   inverseObjectProperties()
|   objectPropertyDomain()
|   objectPropertyRange() 
|   functionalObjectProperty()
|   inverseFunctionalObjectProperty() 
|   reflexiveObjectProperty()
|   irreflexiveObjectProperty()
|   symmetricObjectProperty()
|   asymmetricObjectProperty()
|   x = transitiveObjectProperty()
   ) { return x; }
}
/* 9.2.1 Object Subproperties */
Future<? extends ElkSubObjectPropertyOfAxiom> subObjectPropertyOf():
{
  Future<? extends ElkObjectPropertyChain> y = null;
  Future<? extends ElkObjectPropertyExpression> x = null;
  Future<? extends ElkObjectPropertyExpression> z;
  boolean isChain;  
}{
    <SUB_OBJECT_PROPERTY_OF> <OPEN_BRACE> 
        axiomAnnotations() 
        (
          x = objectPropertyExpression() { isChain = false; }
        | y = propertyExpressionChain()  { isChain = true; }
        ) 
        z = objectPropertyExpression() 
    <CLOSE_BRACE> {
      if (isChain)
        // TODO: support role chains
        return null;
        // ElkSubObjectPropertyOfAxiom.create(y, z);
      else
        return constructor.getFutureElkSubObjectPropertyOfAxiom(x, z);
    }
}
Future<? extends ElkObjectPropertyChain> propertyExpressionChain():
{
  Future<? extends ElkObjectPropertyExpression> x;
  Vector<Future<? extends ElkObjectPropertyExpression>> v = 
             new Vector<Future<? extends ElkObjectPropertyExpression>> (2);
}{
    <OBJECT_PROPERTY_CHAIN> <OPEN_BRACE> 
          x = objectPropertyExpression() { v.add(x); }        
        ( x = objectPropertyExpression() { v.add(x); } )+ 
    <CLOSE_BRACE> {
      return constructor.getFutureElkObjectPropertyChain(v);  
    }
}
/* 9.2.2 Equivalent Object Properties */    
void equivalentObjectProperties():
{}{
    <EQUIVALENT_OBJECT_PROPERTIES> <OPEN_BRACE> 
        axiomAnnotations() 
        objectPropertyExpression() 
        ( objectPropertyExpression() )+ 
    <CLOSE_BRACE>
}
/* 9.2.3 Disjoint Object Properties */
void disjointObjectProperties():
{}{
    <DISJOINT_OBJECT_PROPERTIES> <OPEN_BRACE> 
        axiomAnnotations() 
        objectPropertyExpression() 
        ( objectPropertyExpression() )+ 
    <CLOSE_BRACE>
}
/* 9.2.4 Inverse Object Properties */
void inverseObjectProperties():
{}{
    <INVERSE_OBJECT_PROPERTIES> <OPEN_BRACE> 
        axiomAnnotations() 
        objectPropertyExpression() 
        objectPropertyExpression() 
    <CLOSE_BRACE>
}
/* 9.2.5 Object Property Domain */
void objectPropertyDomain():
{}{
    <OBJECT_PROPERTY_DOMAIN> <OPEN_BRACE> 
        axiomAnnotations() 
        objectPropertyExpression() 
        classExpression() 
    <CLOSE_BRACE>
}
/* 9.2.6 Object Property Range */        
void objectPropertyRange():
{}{
    <OBJECT_PROPERTY_RANGE> <OPEN_BRACE> 
        axiomAnnotations() 
        objectPropertyExpression() 
        classExpression() 
    <CLOSE_BRACE>
}
/* 9.2.7 Functional Object Properties */
void functionalObjectProperty():
{}{
    <FUNCTIONAL_OBJECT_PROPERTY> <OPEN_BRACE> 
        axiomAnnotations() 
        objectPropertyExpression() 
    <CLOSE_BRACE>
}
/* 9.2.8 Inverse-Functional Object Properties */    
void inverseFunctionalObjectProperty():
{}{
    <INVERSE_FUNCTIONAL_OBJECT_PROPERTY> <OPEN_BRACE> 
        axiomAnnotations() 
        objectPropertyExpression() 
    <CLOSE_BRACE>
}
/* 9.2.9 Reflexive Object Properties */
void reflexiveObjectProperty():
{}{
    <REFLEXIVE_OBJECT_PROPERTY> <OPEN_BRACE> 
        axiomAnnotations() 
        objectPropertyExpression() 
    <CLOSE_BRACE>
}
/* 9.2.10 Irreflexive Object Properties */
void irreflexiveObjectProperty():
{}{
    <IRREFLEXIVE_OBJECT_PROPERTY> <OPEN_BRACE> 
        axiomAnnotations() 
        objectPropertyExpression() 
    <CLOSE_BRACE>
}
/* 9.2.11 Symmetric Object Properties */
void symmetricObjectProperty():
{}{
    <SYMMETRIC_OBJECT_PROPERTY> <OPEN_BRACE> 
        axiomAnnotations() 
        objectPropertyExpression() 
    <CLOSE_BRACE>
}
/* 9.2.12 Asymmetric Object Properties */
void asymmetricObjectProperty():
{}{
    <ASYMMETRIC_OBJECT_PROPERTY> <OPEN_BRACE> 
        axiomAnnotations() 
        objectPropertyExpression() 
    <CLOSE_BRACE>
}
/* 9.2.13 Transitive Object Properties */
Future<? extends ElkTransitiveObjectPropertyAxiom> transitiveObjectProperty():
{
    Future<? extends ElkObjectPropertyExpression> x; 
}{  
    <TRANSITIVE_OBJECT_PROPERTY> <OPEN_BRACE> 
        axiomAnnotations() 
        x = objectPropertyExpression() 
    <CLOSE_BRACE>{
        return constructor.getFutureElkTransitiveObjectPropertyAxiom(x);
    } 
}
/* 9.3 Data Property Axioms */    
void dataPropertyAxiom():
{}{
    subDataPropertyOf() 
|   equivalentDataProperties() 
|   disjointDataProperties() 
|   dataPropertyDomain() 
|   dataPropertyRange() 
|   functionalDataProperty()
}
/* 9.3.1 Data Subproperties */
void subDataPropertyOf():
{}{
    <SUB_DATA_PROPERTY_OF> <OPEN_BRACE> 
        axiomAnnotations() 
        subDataPropertyExpression() 
        superDataPropertyExpression() 
    <CLOSE_BRACE>
}    
void subDataPropertyExpression():
{}{
    dataPropertyExpression()
}
void superDataPropertyExpression():
{}{
    dataPropertyExpression()
}
/* 9.3.2 Equivalent Data Properties */
void equivalentDataProperties():
{}{
    <EQUIVALENT_DATA_PROPERTIES> <OPEN_BRACE> 
        axiomAnnotations() 
        dataPropertyExpression() 
        ( dataPropertyExpression() )+ 
    <CLOSE_BRACE>
}
/* 9.3.3 Disjoint Data Properties */
void disjointDataProperties():
{}{
    <DISJOINT_DATA_PROPERTIES> <OPEN_BRACE> 
        axiomAnnotations() 
        dataPropertyExpression() 
        ( dataPropertyExpression() )+ 
    <CLOSE_BRACE>
}
/* 9.3.4 Data Property Domain */
void dataPropertyDomain():
{}{
    <DATA_PROPERTY_DOMAIN> <OPEN_BRACE> 
        axiomAnnotations() 
        dataPropertyExpression() 
        classExpression() 
    <CLOSE_BRACE>
}
/* 9.3.5 Data Property Range */
void dataPropertyRange():
{}{
    <DATA_PROPERTY_RANGE> <OPEN_BRACE> 
        axiomAnnotations() 
        dataPropertyExpression() 
        dataRange() 
    <CLOSE_BRACE>
}
/* 9.3.6 Functional Data Properties */
void functionalDataProperty():
{}{
    <FUNCTIONAL_DATA_PROPERTY> <OPEN_BRACE> 
        axiomAnnotations() 
        dataPropertyExpression() 
    <CLOSE_BRACE>
}
/* 9.4 Datatype Definitions */
void datatypeDefinition():
{}{
    <DATATYPE_DEFINITION> <OPEN_BRACE>
      axiomAnnotations()
      datatype()
      dataRange()
    <CLOSE_BRACE>
}
/* 9.5 Keys */
void hasKey():
{}{
    <HAS_KEY> <OPEN_BRACE> 
        axiomAnnotations() 
        classExpression() 
        <OPEN_BRACE> ( objectPropertyExpression() )* <CLOSE_BRACE> 
        <OPEN_BRACE> ( dataPropertyExpression() )* <CLOSE_BRACE> 
    <CLOSE_BRACE>
}
/* 9.6 Assertions */    
void assertion():
{}{
    sameIndividual() 
|   differentIndividuals() 
|   classAssertion() 
|   objectPropertyAssertion() 
|   negativeObjectPropertyAssertion() 
|   dataPropertyAssertion() 
|   negativeDataPropertyAssertion()
}
void sourceIndividual():
{}{
    individual()
}
void targetIndividual():
{}{
    individual()
}
void targetValue():
{}{
    literal()
}
/* 9.6.1 Individual Equality */
void sameIndividual():
{}{
    <SAME_INDIVIDUAL> <OPEN_BRACE>
      axiomAnnotations()
      individual()
      ( individual() )+
    <CLOSE_BRACE>
}
/* 9.6.2 Individual Inequality */
void differentIndividuals():
{}{
    <DIFFERENT_INDIVIDUALS> <OPEN_BRACE>
      axiomAnnotations()
      individual()
      ( individual() )+
    <CLOSE_BRACE>
}
/* 9.6.3 Class Assertions */
void classAssertion():
{}{
    <CLASS_ASSERTION> <OPEN_BRACE>
      axiomAnnotations()
      classExpression()
      individual()
    <CLOSE_BRACE>
}
/* 9.6.4 Positive Object Property Assertions */
void objectPropertyAssertion():
{}{
    <OBJECT_PROPERTY_ASSERTION> <OPEN_BRACE> 
        axiomAnnotations() 
        objectPropertyExpression() 
        sourceIndividual() 
        targetIndividual() 
    <CLOSE_BRACE>
}
/* 9.6.5 Negative Object Property Assertions */
void negativeObjectPropertyAssertion():
{}{
    <NEGATIVE_OBJECT_PROPERTY_ASSERTION> <OPEN_BRACE> 
        axiomAnnotations() 
        objectPropertyExpression() 
        sourceIndividual() 
        targetIndividual() 
    <CLOSE_BRACE>
}
/* 9.6.6 Positive Data Property Assertions */
void dataPropertyAssertion():
{}{
    <DATA_PROPERTY_ASSERTION> <OPEN_BRACE> 
        axiomAnnotations() 
        dataPropertyExpression() 
        sourceIndividual() 
        targetValue() 
    <CLOSE_BRACE>
}
/* 9.6.7 Negative Data Property Assertions */
void negativeDataPropertyAssertion():
{}{
    <NEGATIVE_DATA_PROPERTY_ASSERTION> <OPEN_BRACE> 
        axiomAnnotations() 
        dataPropertyExpression() 
        sourceIndividual() 
        targetValue() 
    <CLOSE_BRACE>
}
/* 10 Annotations */
/* 10.1 Annotations of Ontologies, Axioms, and other Annotations */
void annotation():
{}{
    <ANNOTATION> <OPEN_BRACE> 
        annotationAnnotations() 
        annotationProperty() 
        annotationValue() 
    <CLOSE_BRACE>
}
void annotationAnnotations():
{}{
    ( annotation() )*
}
void annotationValue():
{}{
    anonymousIndividual() | iri() | literal()
}
/* 10.2 Annotation Axioms */    
void annotationAxiom():
{}{
    annotationAssertion() 
|   subAnnotationPropertyOf() 
|   annotationPropertyDomain() 
|   annotationPropertyRange()
}
/* 10.2.1 Annotation Assertion */
void annotationAssertion():
{}{
    <ANNOTATION_ASSERTION> <OPEN_BRACE> 
        axiomAnnotations() 
        annotationProperty() 
        annotationSubject() 
        annotationValue() 
    <CLOSE_BRACE>
}
void annotationSubject():
{}{
    iri() | anonymousIndividual()
}
/* 10.2.2 Annotation Subproperties */
void subAnnotationPropertyOf():
{}{
    <SUB_ANNOTATION_PROPERTY_OF> <OPEN_BRACE> 
        axiomAnnotations() 
        subAnnotationProperty() 
        superAnnotationProperty() 
    <CLOSE_BRACE>
}
void subAnnotationProperty():
{}{
    annotationProperty()
}
void superAnnotationProperty():
{}{
    annotationProperty()
}
/* 10.2.3 Annotation Property Domain */
void annotationPropertyDomain():
{}{
    <ANNOTATION_PROPERTY_DOMAIN> <OPEN_BRACE>
      axiomAnnotations()
      annotationProperty()
      iri()
    <CLOSE_BRACE>
}
/* 10.2.4 Annotation Property Range */
void annotationPropertyRange():
{}{
    <ANNOTATION_PROPERTY_RANGE> <OPEN_BRACE>
      axiomAnnotations()
      annotationProperty()
      iri()
    <CLOSE_BRACE>
}
